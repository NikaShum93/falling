<!doctype html> 
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Falling Items — Game</title>
<style>
    :root{
        --glow:#00f0ff;
    }
    html,body{height:100%}
    body{
        margin:0;
        background:#0d0d0d;
        color:#fff;
        overflow:hidden;
        font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
        /* Установит курсор, если он задан в JS */
    }
    #game{
        position:relative;
        width:100%;
        height:100%;
        overflow:hidden;
    }

    /* HUD */
    .hud{
        position:fixed; left:12px; top:12px; right:12px; display:flex; gap:12px; align-items:center; justify-content:space-between;
        font-weight:700; z-index:10; pointer-events:none;
    }
    .badge{
        pointer-events:none;
        background:rgba(0,0,0,.45);
        border:1px solid rgba(255,255,255,.12);
        border-radius:12px;
        padding:10px 14px;
        box-shadow:0 8px 24px rgba(0,0,0,.35), 0 0 18px rgba(255,215,0,.08) inset;
    }
    .levelTitle{color:#ffd700}
    .timer{min-width:110px; text-align:center}
    .score{min-width:110px; text-align:center}
    
    /* Сообщение о штрафе */
    .penalty {
        position: absolute;
        color: #ff3333;
        font-size: 30px;
        font-weight: 900;
        opacity: 0;
        z-index: 15;
        pointer-events: none;
        animation: fadeOut 0.8s ease-out forwards;
    }
    @keyframes fadeOut {
        0% { opacity: 1; transform: translateY(0); }
        100% { opacity: 0; transform: translateY(-40px); }
    }

    /* падающий элемент = контейнер */
    .item{
        position:absolute;
        top:-140px;
        left:0;
        transform:translateZ(0);
        will-change:transform, top, left;
        display:inline-flex;
        align-items:center;
        justify-content:center;
        min-width:120px;
        min-height:80px;
        padding:0;
        user-select:none;
        cursor:pointer;
    }
    /* фон-слой */
    .item .bg{
        position:absolute; inset:0;
        background:#222;
        opacity:1;
        border:0 solid #fff;
        box-shadow:none;
        transition:filter .15s ease, box-shadow .15s ease;
    }
    /* слой контента */
    .item .content{
        position:relative; z-index:1;
        display:flex; align-items:center; justify-content:center;
        padding:20px 26px;
        max-width:320px;
        max-height:220px;
        text-align:center;
        line-height:1.15;
    }
    .item .content span{
        display:inline-block;
        font-weight:800;
        white-space:nowrap;
    }
    .item .content img{
        display:block;
        max-width:180px;
        max-height:140px;
        object-fit:contain;
        pointer-events:none;
    }

    /* ФИГУРЫ */
    .shape-rect .bg{ border-radius:10px }
    .shape-rounded .bg{ border-radius:20px }
    .shape-circle .bg{ border-radius:50% }
    .shape-diamond .bg{ clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%) }
    .shape-star .bg{ clip-path:polygon(50% 0%,61% 35%,98% 35%,68% 57%,79% 91%,50% 70%,21% 91%,32% 57%,2% 35%,39% 35%) }

    /* ЭФФЕКТЫ */
    .fx-shadow .bg{ box-shadow:0 10px 30px rgba(0,0,0,.5) }
    .fx-3d .bg{ box-shadow:
        7px 7px 20px rgba(0,0,0,.5),
        inset -5px -5px 12px rgba(255,255,255,.22) }
    .fx-glow .bg{ box-shadow:0 0 18px var(--glow, #00f0ff) }
    .fx-border .bg{ border-style:solid }

    /* клик-поп */
    .caught{ animation:pop .45s ease forwards }
    @keyframes pop{
        0%{ transform:scale(1); opacity:1 }
        50%{ transform:scale(1.15); opacity:1 }
        100%{ transform:scale(0.85); opacity:0 }
    }

    /* блёстки */
    .sparkle{
        position:absolute;
        width:6px; height:6px; border-radius:50%;
        background:rgba(255,255,255,.9);
        pointer-events:none;
        animation:spark 0.9s forwards;
        filter:drop-shadow(0 0 6px #fff);
        z-index:5;
    }
    @keyframes spark{
        from{ opacity:1; transform:translate(0,0) scale(1) }
        to{ opacity:0; transform:translate(var(--dx), var(--dy)) scale(.2) }
    }

    /* финальный экран */
    .overlay{
        position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column;
        background:linear-gradient(180deg, rgba(0,0,0,.5), rgba(0,0,0,.9));
        color:#fff; z-index:20; gap:18px;
    }
    .overlay .panel{
        background:rgba(0,0,0,.55);
        border:1px solid rgba(255,255,255,.12);
        border-radius:16px;
        padding:20px 26px;
        text-align:center;
        box-shadow:0 0 26px rgba(255,215,0,.1);
    }
    .overlay button{
        background:linear-gradient(90deg,#ffbf00,#ffd700);
        color:#000; border:0; border-radius:10px; font-weight:900; padding:12px 16px; cursor:pointer;
    }
</style>
</head>
<body>

<div class="hud">
    <div class="badge levelTitle" id="hudLevel">Уровень</div>
    <div class="badge timer" id="hudTimer">00</div>
    <div class="badge score" id="hudScore">0</div>
</div>

<div id="game"></div>

<audio id="popSound" src="pop.mp3" preload="auto"></audio>

<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<script>
(async function(){

    // ===== utils =====
    const $ = sel => document.querySelector(sel);
    const rnd = (a,b)=> a + Math.random()*(b-a);
    const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));
    
    // Вспомогательная функция для отображения штрафа
    function showPenalty(x, y, amount) {
        const p = document.createElement('div');
        p.className = 'penalty';
        p.textContent = amount > 0 ? `+${amount}` : amount;
        p.style.left = `${x}px`;
        p.style.top = `${y}px`;
        document.body.appendChild(p);
        setTimeout(() => p.remove(), 800);
    }

    // ===== загрузка конфига =====
    const params = new URLSearchParams(location.search);
    const id = params.get('id');
    if(!id){ alert('Не передан id'); return; }

    const jsonUrl = `https://nikashum93.github.io/texts/data/${id}.json`;
    let cfg;
    try{
        const res = await fetch(jsonUrl, { cache:'no-store' });
        cfg = await res.json();
    }catch(e){
        alert('Ошибка загрузки настроек: ' + e.message);
        return;
    }

    // глобальные из редактора
    const SPEED = clamp(Number(cfg.speed ?? 5), 1, 10);
    const FONT = cfg.font || 'Rubik';
    const FONT_SIZE = Number(cfg.fontSize || 24);
    const TEXT_COLOR = cfg.textColor || '#ffffff';
    const STYLE = cfg.style || {};
    const CURSOR = cfg.cursor || '';

    // подгружаем шрифт
    const gf = document.createElement('link');
    gf.rel = 'stylesheet';
    // Чистка имени шрифта для URL
    gf.href = `https://fonts.googleapis.com/css2?family=${FONT.replace(/ /g, '+')}:wght@400;700&display=swap`;
    document.head.appendChild(gf);

    // курсор
    if(CURSOR) document.body.style.cursor = `url(${CURSOR}), auto`;

    // уровни
    const levels = Array.isArray(cfg.levels) ? [...cfg.levels] : [];
    if(cfg.randomLevels){
        for(let i=levels.length-1; i>0; i--){
            const j = Math.floor(Math.random()*(i+1));
            [levels[i], levels[j]] = [levels[j], levels[i]];
        }
    }

    const game = $('#game');
    const popSound = $('#popSound');
    const hudLevel = $('#hudLevel');
    const hudTimer = $('#hudTimer');
    const hudScore = $('#hudScore');

    let score = 0;
    let current = 0;
    let levelTimerHandle = null;
    let spawnerHandle = null;
    let running = true;

    // Начало игры
    if(levels.length > 0) {
         // Запускаем игру по первому клику, чтобы обойти блокировку аудио
        showStartOverlay(); 
    } else {
        alert('Ошибка: Нет настроенных уровней.');
    }

    function showStartOverlay() {
        const ov = document.createElement('div');
        ov.className = 'overlay';
        ov.innerHTML = `
            <div class="panel">
                <div style="font-size:24px; color:#ffd700; font-weight:900; margin-bottom:12px">Начать игру!</div>
                <button id="btnStart">СТАРТ</button>
            </div>
        `;
        document.body.appendChild(ov);
        $('#btnStart').onclick = () => {
            ov.remove();
            startLevel();
        };
    }
    
    // ===== старт уровня =====
    function startLevel(){
        if(current >= levels.length){ showFinish(); return; }
        const lv = levels[current];
        hudLevel.textContent = `Уровень ${current+1}: ${lv.target || ''}`;

        // таймер уровня
        let timeLeft = Math.max(5, Number(lv.timer || 30));
        hudTimer.textContent = timeLeft.toString().padStart(2,'0');
        if(levelTimerHandle) clearInterval(levelTimerHandle);
        levelTimerHandle = setInterval(()=>{
            if(!running) return;
            timeLeft--;
            hudTimer.textContent = timeLeft.toString().padStart(2,'0');
            if(timeLeft <= 0){
                clearInterval(levelTimerHandle);
                clearInterval(spawnerHandle);
                // Удаляем все падающие элементы перед переходом
                document.querySelectorAll('.item').forEach(n=>n.remove()); 
                current++;
                startLevel();
            }
        }, 1000);

        // спавн
        if(spawnerHandle) clearInterval(spawnerHandle);
        const pool = [
            ...(lv.correct||[]).map(v=>({val:v, good:true})),
            ...(lv.wrong||[]).map(v=>({val:v, good:false}))
        ];
        // Если пул пуст, не спавним
        if (pool.length === 0) return; 

        const baseDelay = 1200;
        const delay = clamp(baseDelay / (SPEED/5), 280, 3000);
        spawnerHandle = setInterval(()=>{
            if(!running) return;
            const obj = pool[Math.floor(Math.random()*pool.length)];
            drop(obj);
        }, delay);
    }

    // ===== создание и падение =====
    function drop(obj){
        const el = document.createElement('div');
        el.className = `item shape-${STYLE.shape || 'rounded'} ${STYLE.shadow?'fx-shadow':''} ${STYLE.fx3d?'fx-3d':''} ${STYLE.glow?'fx-glow':''} ${STYLE.borderOn && STYLE.borderWidth>0 ? 'fx-border' : ''}`;
        el.dataset.good = obj.good ? '1' : '0';
        el.style.setProperty('--glow', STYLE.glowColor || '#00f0ff');

        const bg = document.createElement('div');
        bg.className = 'bg';
        const content = document.createElement('div');
        content.className = 'content';
        el.appendChild(bg); el.appendChild(content);

        const bgImg = (STYLE.bgImage||'').trim();
        const bgCol = STYLE.bgColor || 'transparent';
        bg.style.background = bgImg ? `url(${bgImg}) center/contain no-repeat, ${bgCol}` : bgCol;
        bg.style.opacity = clamp(Number(STYLE.opacity ?? 1), 0, 1);
        if(STYLE.borderOn && STYLE.borderWidth>0){
            bg.style.borderColor = STYLE.borderColor || '#fff';
            bg.style.borderWidth = `${parseInt(STYLE.borderWidth,10)}px`;
        } else {
            bg.style.borderWidth = '0px';
        }

        if(/^https?:\/\//i.test(obj.val)){
            const img = document.createElement('img');
            img.src = obj.val;
            content.appendChild(img);
        } else if((cfg.language||'') === 'math'){
            const span = document.createElement('span');
            span.textContent = `\\(${obj.val}\\)`;
            content.appendChild(span);
        } else {
            const span = document.createElement('span');
            span.textContent = String(obj.val);
            span.style.color = TEXT_COLOR;
            span.style.fontFamily = `${FONT}, system-ui, sans-serif`;
            span.style.fontSize = `${FONT_SIZE}px`;
            content.appendChild(span);
        }

        const gw = game.clientWidth;
        const startX = Math.max(16, Math.min(gw-180, rnd(0, gw-180)));
        el.style.left = startX + 'px';
        el.style.top = '-160px';

        game.appendChild(el);
        fitGeometryBox(el);
        autoFitText(el, FONT_SIZE, 12);

        // MathJax: Промис и подгонка геометрии
        if((cfg.language||'') === 'math') {
            MathJax.typesetPromise([el]).then(()=> { fitGeometryBox(el); });
        }

        const vel = 1.2 + SPEED * 0.9;
        const swayAmp = rnd(8, 22);
        const swayFreq = rnd(0.003, 0.008);
        let y = -140;
        let t = 0;
        let alive = true;

        function step(){
            if(!alive) return;
            y += vel; t += 1;
            const dx = Math.sin(t*swayFreq) * swayAmp;
            el.style.top = y+'px';
            el.style.transform = `translateX(${dx}px)`;

            if(y > game.clientHeight + 200){
                alive = false; 
                
                // ИСПРАВЛЕНО: Штраф за пропущенный правильный элемент
                if(el.dataset.good === '1'){
                    score = Math.max(0, score - 5);
                    hudScore.textContent = score;
                    // Визуальный штраф
                    const r = el.getBoundingClientRect();
                    showPenalty(r.left + r.width/2, r.top + r.height/2, -5);
                }
                
                el.remove();
                return;
            }
            requestAnimationFrame(step);
        }
        requestAnimationFrame(step);

        el.addEventListener('click', ()=>{
            if(!alive) return;
            const r = el.getBoundingClientRect();

            if(el.dataset.good === '1'){
                score++; hudScore.textContent = score;
                playPop(el);
                alive = false;
                el.classList.add('caught');
                setTimeout(()=> el.remove(), 400);
            } else {
                // ИСПРАВЛЕНО: Штраф за клик по неправильному элементу
                score = Math.max(0, score - 2); 
                hudScore.textContent = score;
                
                // Улучшенная обратная связь: красное свечение
                bg.style.filter = 'brightness(1.5) saturate(1.8) hue-rotate(-30deg)';
                bg.style.boxShadow = '0 0 18px #ff3333';
                setTimeout(()=> { 
                    bg.style.filter = 'none'; 
                    bg.style.boxShadow = STYLE.glow?'0 0 18px var(--glow, #00f0ff)':'none';
                }, 220);
                
                // Визуальный штраф
                showPenalty(r.left + r.width/2, r.top + r.height/2, -2);
            }
        });
    }

    // ===== геометрия =====
    function fitGeometryBox(el){
        const shape = STYLE.shape || 'rounded';
        const content = el.querySelector('.content');
        const rect = content.getBoundingClientRect();

        // Устанавливаем базовые размеры
        el.style.width = (rect.width) + 'px';
        el.style.height = (rect.height) + 'px';

        // Дополнительная подгонка для круглых и сложных форм
        if(shape === 'circle' || shape === 'diamond' || shape === 'star'){
            const size = Math.max(rect.width, rect.height) + 40; // Увеличен padding
            el.style.width = size + 'px';
            el.style.height = size + 'px';
        }
    }

    // ===== автофит текста =====
    function autoFitText(el, startPx, minPx){
        const span = el.querySelector('.content span');
        if(!span) return;
        let fs = startPx;
        // Учитываем padding (20px с каждой стороны = 40px)
        const maxW = el.clientWidth - 40; 
        const maxH = el.clientHeight - 40; 
        const measure = ()=> span.getBoundingClientRect().width <= maxW && span.getBoundingClientRect().height <= maxH;
        while(fs > minPx){
            span.style.fontSize = fs + 'px';
            if(measure()) break;
            fs -= 1;
        }
    }

    // ===== эффекты при клике =====
    function playPop(el){
        // Улучшенная обработка аудио
        popSound.muted = false;
        try{ popSound.currentTime = 0; popSound.play(); }catch(_){}
        
        const r = el.getBoundingClientRect();
        for(let i=0;i<14;i++){
            const s = document.createElement('div');
            s.className = 'sparkle';
            s.style.left = (r.left + r.width/2) + 'px';
            s.style.top  = (r.top  + r.height/2) + 'px';
            const angle = Math.random() * Math.PI * 2;
            const dist = 40 + Math.random()*70;
            s.style.setProperty('--dx', (Math.cos(angle)*dist) + 'px');
            s.style.setProperty('--dy', (Math.sin(angle)*dist) + 'px');
            s.style.animationDuration = (0.9 / (SPEED/5)) + 's';
            document.body.appendChild(s);
            setTimeout(()=> s.remove(), 1000);
        }
    }

    // ===== финал =====
    function showFinish(){
        const ov = document.createElement('div');
        ov.className = 'overlay';
        ov.innerHTML = `
            <div class="panel">
                <div style="font-size:22px; color:#ffd700; font-weight:900; margin-bottom:8px">Финиш! 🎉</div>
                <div style="opacity:.9; margin-bottom:10px">Финальный счёт: <b>${score}</b></div>
                <button id="btnAgain">Начать заново</button>
            </div>
        `;
        document.body.appendChild(ov);
        $('#btnAgain').onclick = ()=> location.reload();
    }
    
    // Пересчет размеров при изменении размера окна
    window.addEventListener('resize', ()=> {
        document.querySelectorAll('.item').forEach(el => {
            fitGeometryBox(el);
            autoFitText(el, FONT_SIZE, 12);
        });
    });


})();
</script>
</body>
</html>
