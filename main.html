<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Falling Items — Game</title>
  <style>
    :root{ --glow:#00f0ff; }
    html,body{height:100%}
    body{
      margin:0;
      background:transparent; /* сцена прозрачная */
      color:#fff;
      overflow:hidden;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    }
    #game{
      position:relative; width:100%; height:100%; overflow:hidden;
    }

    /* HUD */
    .hud{
      position:fixed; left:12px; top:12px; right:12px; display:flex; gap:12px; align-items:center; justify-content:space-between;
      font-weight:700; z-index:30; pointer-events:none;
    }
    .badge{
      pointer-events:none;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 14px;
      box-shadow:0 8px 24px rgba(0,0,0,.35), 0 0 18px rgba(255,215,0,.08) inset;
    }
    .levelTitle{color:#ffd700}
    .timer{min-width:110px; text-align:center}
    .score{min-width:110px; text-align:center}

    /* стартовый оверлей для разрешения звука */
    .startOverlay{
      position:fixed; inset:0; z-index:40;
      display:flex; align-items:center; justify-content:center; flex-direction:column; gap:16px;
      background:linear-gradient(180deg, rgba(0,0,0,.55), rgba(0,0,0,.9));
      color:#fff;
    }
    .startOverlay .panel{
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:22px 26px;
      text-align:center;
      box-shadow:0 0 26px rgba(255,215,0,.1);
    }
    .startOverlay button{
      background:linear-gradient(90deg,#ffbf00,#ffd700);
      color:#000; border:0; border-radius:10px; font-weight:900; padding:12px 16px; cursor:pointer;
    }

    /* падающий элемент = контейнер (двухслойный) */
    .item{
      position:absolute; left:0; top:-160px;
      transform:translateZ(0);
      will-change:transform, top, left;
      display:inline-flex; align-items:center; justify-content:center;
      min-width:140px; min-height:64px;
      user-select:none; cursor:pointer;
      isolation:isolate; /* чтобы фон и контент не смешивались */
    }
    /* слой фона (клипуем, в нём рамка/тени/прозрачность/картинка) */
    .item .bg{
      position:absolute; inset:0; z-index:0;
      background:transparent;
      opacity:1;
      border:0 solid #fff; /* управляется из JS */
      box-shadow:none;     /* эффекты из JS */
      transition:filter .15s ease;
    }
    /* слой контента (НЕ клипуется) */
    .item .content{
      position:relative; z-index:1;
      display:flex; align-items:center; justify-content:center;
      padding:20px 26px; /* текст поверх фоновой картинки — не режем по clip-path */
      max-width:320px; max-height:220px;
      text-align:center; line-height:1.15;
    }
    .item .content span{
      display:inline-block; font-weight:800; white-space:nowrap;
    }
    .item .content img{
      display:block; max-width:180px; max-height:140px; object-fit:contain; pointer-events:none;
    }

    /* ФИГУРЫ: клипуем ТОЛЬКО фон */
    .shape-rect   .bg{ border-radius:10px }
    .shape-rounded .bg{ border-radius:20px }
    .shape-circle .bg{ border-radius:50% }
    .shape-diamond .bg{ clip-path:polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%) }
    .shape-star    .bg{ clip-path:polygon(50% 0%,61% 35%,98% 35%,68% 57%,79% 91%,50% 70%,21% 91%,32% 57%,2% 35%,39% 35%) }

    /* ЭФФЕКТЫ на bg */
    .fx-shadow .bg{ box-shadow:0 10px 30px rgba(0,0,0,.5) }
    .fx-3d .bg{ box-shadow:7px 7px 20px rgba(0,0,0,.5), inset -5px -5px 12px rgba(255,255,255,.22) }
    .fx-glow .bg{ box-shadow:0 0 18px var(--glow, #00f0ff) }
    .fx-border .bg{ border-style:solid }

    /* клик-поп */
    .caught{ animation:pop .45s ease forwards }
    @keyframes pop{
      0%{ transform:scale(1); opacity:1 }
      50%{ transform:scale(1.15); opacity:1 }
      100%{ transform:scale(0.85); opacity:0 }
    }

    /* блёстки */
    .sparkle{
      position:fixed;
      width:6px; height:6px; border-radius:50%;
      background:rgba(255,255,255,.9);
      pointer-events:none;
      animation:spark 0.9s forwards;
      filter:drop-shadow(0 0 6px #fff);
      z-index:50;
    }
    @keyframes spark{
      from{ opacity:1; transform:translate(0,0) scale(1) }
      to{ opacity:0; transform:translate(var(--dx), var(--dy)) scale(.2) }
    }

    /* финальный экран */
    .overlay{
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center; flex-direction:column;
      background:linear-gradient(180deg, rgba(0,0,0,.5), rgba(0,0,0,.9));
      color:#fff; z-index:45; gap:18px;
    }
    .overlay .panel{
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius:16px;
      padding:20px 26px;
      text-align:center;
      box-shadow:0 0 26px rgba(255,215,0,.1);
    }
    .overlay button{
      background:linear-gradient(90deg,#ffbf00,#ffd700);
      color:#000; border:0; border-radius:10px; font-weight:900; padding:12px 16px; cursor:pointer;
    }
  </style>
</head>
<body>

<div class="hud">
  <div class="badge levelTitle" id="hudLevel">Уровень</div>
  <div class="badge timer" id="hudTimer">00</div>
  <div class="badge score" id="hudScore">0</div>
</div>

<div id="game"></div>

<div class="startOverlay" id="startOv" hidden>
  <div class="panel">
    <div style="font-size:20px; margin-bottom:10px">Готово к старту</div>
    <button id="btnStart">Старт</button>
  </div>
</div>

<audio id="popSound" src="pop.mp3" preload="auto"></audio>

<!-- MathJax для формул -->
<script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" async></script>

<script>
(async function(){

  const $ = sel => document.querySelector(sel);
  const rnd = (a,b)=> a + Math.random()*(b-a);
  const clamp = (v,min,max)=> Math.max(min, Math.min(max,v));

  // ===== загрузка конфига =====
  const params = new URLSearchParams(location.search);
  const id = params.get('id');
  if(!id){ alert('Не передан id'); return; }

  const jsonUrl = `https://nikashum93.github.io/texts/data/${encodeURIComponent(id)}.json?v=${Date.now()}`;
  let cfg;
  try{
    const res = await fetch(jsonUrl, { cache:'no-store' });
    if(!res.ok) throw new Error('HTTP '+res.status);
    cfg = await res.json();
  }catch(e){
    alert('Ошибка загрузки настроек: ' + e.message + '\nЕсли только что опубликовали — подождите 30–60 секунд.');
    return;
  }

  // Глобальные из редактора
  const SPEED = clamp(Number(cfg.speed ?? 5), 1, 10); // 1–10
  const FONT = cfg.font || 'Rubik';
  const FONT_SIZE = Number(cfg.fontSize || 24);
  const TEXT_COLOR = cfg.textColor || '#ffffff';
  const STYLE = cfg.style || {};
  const CURSOR = cfg.cursor || '';
  const RANDOM = !!cfg.randomLevels;

  // Шрифт
  const gf = document.createElement('link');
  gf.rel = 'stylesheet';
  gf.href = `https://fonts.googleapis.com/css2?family=${encodeURIComponent(FONT).replace(/%20/g,'+')}%3Awght@400;700&display=swap`;
  document.head.appendChild(gf);

  // Курсор
  if(CURSOR) document.body.style.cursor = `url(${CURSOR}), auto`;

  // Уровни
  const levels = Array.isArray(cfg.levels) ? [...cfg.levels] : [];
  if(RANDOM){
    for(let i=levels.length-1; i>0; i--){
      const j = Math.floor(Math.random()*(i+1));
      [levels[i], levels[j]] = [levels[j], levels[i]];
    }
  }

  const game = $('#game');
  const popSound = $('#popSound');
  const hudLevel = $('#hudLevel');
  const hudTimer = $('#hudTimer');
  const hudScore = $('#hudScore');
  const startOv  = $('#startOv');
  const btnStart = $('#btnStart');

  let score = 0;
  let current = 0;
  let levelTimerHandle = null;
  let spawnerHandle = null;
  let running = false; // начнём после «Старт»
  let audioPrimed = false;

  // стартовый оверлей, чтобы снять блок на звук
  startOv.hidden = false;
  btnStart.addEventListener('click', async ()=>{
    startOv.hidden = true;
    running = true;
    // пробуем заглушкой «разбудить» аудио
    try{ popSound.muted = true; popSound.play(); await new Promise(r=>setTimeout(r,50)); popSound.pause(); popSound.currentTime=0; popSound.muted=false; audioPrimed = true; }catch{}
    startLevel();
  });

  function startLevel(){
    if(!running) return;
    if(current >= levels.length){ showFinish(); return; }
    const lv = levels[current];
    hudLevel.textContent = `Уровень ${current+1}: ${lv.target || ''}`;

    // таймер уровня
    let timeLeft = Math.max(5, Number(lv.timer || 30));
    hudTimer.textContent = timeLeft.toString().padStart(2,'0');
    clearInterval(levelTimerHandle);
    levelTimerHandle = setInterval(()=>{
      if(!running) return;
      timeLeft--;
      hudTimer.textContent = timeLeft.toString().padStart(2,'0');
      if(timeLeft <= 0){
        clearInterval(levelTimerHandle);
        clearInterval(spawnerHandle);
        document.querySelectorAll('.item').forEach(n=>n.remove());
        current++;
        startLevel();
      }
    }, 1000);

    // спавн
    clearInterval(spawnerHandle);
    const pool = [
      ...(lv.correct||[]).map(v=>({val:v, good:true})),
      ...(lv.wrong||[]).map(v=>({val:v, good:false}))
    ];
    if(pool.length===0){ // если пусто — просто перескакиваем
      current++; startLevel(); return;
    }

    const baseDelay = 1200;
    const delay = clamp(baseDelay / (SPEED/5), 280, 3000); // быстрее при большем SPEED

    spawnerHandle = setInterval(()=>{
      if(!running) return;
      const obj = pool[Math.floor(Math.random()*pool.length)];
      drop(obj);
    }, delay);
  }

  // создание и падение
  function drop(obj){
    const el = document.createElement('div');
    el.className = `item shape-${STYLE.shape || 'rounded'} ${STYLE.shadow?'fx-shadow':''} ${STYLE.fx3d?'fx-3d':''} ${STYLE.glow?'fx-glow':''} ${STYLE.borderOn && STYLE.borderWidth>0 ? 'fx-border' : ''}`;
    el.dataset.good = obj.good ? '1' : '0';
    el.style.setProperty('--glow', STYLE.glowColor || '#00f0ff');

    // структура
    const bg = document.createElement('div');
    bg.className = 'bg';
    const content = document.createElement('div');
    content.className = 'content';
    el.appendChild(bg); el.appendChild(content);

    // фон-слой: либо картинка, либо цвет (взаимоисключающие)
    const bgImg = (STYLE.bgImage||'').trim();
    const bgCol = STYLE.bgColor || 'transparent';
    if(bgImg){
      bg.style.background = `url(${bgImg}) center/contain no-repeat`;
    } else {
      bg.style.background = bgCol;
    }
    bg.style.opacity = clamp(Number(STYLE.opacity ?? 1), 0, 1);

    if(STYLE.borderOn && STYLE.borderWidth>0){
      bg.style.borderColor = STYLE.borderColor || '#fff';
      bg.style.borderWidth = `${parseInt(STYLE.borderWidth,10)}px`;
    } else {
      bg.style.borderWidth = '0px';
    }

    // контент ( НЕ клипается )
    const isURL = v => /^https?:\/\//i.test(v);
    if(isURL(obj.val)){
      const img = document.createElement('img');
      img.src = obj.val;
      content.appendChild(img);
    } else if((cfg.language||'') === 'math'){
      const span = document.createElement('span');
      span.textContent = `\\(${obj.val}\\)`;
      content.appendChild(span);
    } else {
      const span = document.createElement('span');
      span.textContent = String(obj.val);
      span.style.color = TEXT_COLOR;
      span.style.fontFamily = `${FONT}, system-ui, sans-serif`;
      span.style.fontSize = `${FONT_SIZE}px`;
      content.appendChild(span);
    }

    // Позиция старта
    const gw = game.clientWidth;
    const startX = Math.max(16, Math.min(gw-180, rnd(0, gw-180)));
    el.style.left = startX + 'px';
    el.style.top = '-160px';

    // Вставляем в сцену, затем подгоняем геометрию, чтобы НЕ было приплюснуто
    game.appendChild(el);
    fitGeometryBox(el);
    autoFitText(el, FONT_SIZE, 12);
    fitGeometryBox(el);

    // MathJax — если режим формул
    if((cfg.language||'') === 'math' && window.MathJax && MathJax.typesetPromise){
      MathJax.typesetPromise([el]).then(()=> { fitGeometryBox(el); });
    }

    // падение с лёгким покачиванием
    const vel = 1.2 + SPEED * 0.9;
    const swayAmp = rnd(8, 22);
    const swayFreq = rnd(0.003, 0.008);
    let y = -160, t = 0, alive = true;

    function step(){
      if(!alive) return;
      y += vel; t += 1;
      const dx = Math.sin(t*swayFreq) * swayAmp;
      el.style.top = y+'px';
      el.style.transform = `translateX(${dx}px)`;
      if(y > game.clientHeight + 220){
        alive = false;
        // штраф, если пропущен ПРАВИЛЬНЫЙ
        if(el.dataset.good === '1'){
          score = Math.max(0, score - 5);
          hudScore.textContent = score;
        }
        el.remove();
        return;
      }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);

    // клик
    el.addEventListener('click', ()=>{
      if(!alive) return;
      const isGood = el.dataset.good === '1';
      if(isGood){
        score++; hudScore.textContent = score;
        playPop(el);
        alive = false;
        el.classList.add('caught');
        setTimeout(()=> el.remove(), 420);
      } else {
        // штраф за неверный клик
        score = Math.max(0, score - 1);
        hudScore.textContent = score;
        // визуальная подсказка
        bg.style.filter = 'brightness(2) saturate(1.6) hue-rotate(-30deg)';
        setTimeout(()=> bg.style.filter = 'none', 220);
      }
    });
  }

  // геометрия фигур (квадрат для круг/ромб/звезда) + «воздух»
  function fitGeometryBox(el){
    const content = el.querySelector('.content');
    const bg      = el.querySelector('.bg');
    const shape   = STYLE.shape || 'rounded';
    if(!content || !bg) return;

    // сброс фиксированных размеров для корректного замера
    el.style.width = ''; el.style.height = '';

    // измерим контент
    const r = content.getBoundingClientRect();
    const padX = 10, padY = 10;

    let w = Math.max(140, Math.ceil(r.width))  + padX*2;
    let h = Math.max(64,  Math.ceil(r.height)) + padY*2;

    if(shape === 'circle' || shape === 'diamond' || shape === 'star'){
      const size = Math.max(w, h) + 30; // чтобы не казалось «сжатым»
      w = size; h = size;
    }

    el.style.width  = w + 'px';
    el.style.height = h + 'px';
  }

  // авто-уменьшение текста, чтобы влез внутрь плашки
  function autoFitText(el, startPx, minPx){
    const span = el.querySelector('.content span');
    if(!span) return;
    let fs = startPx;
    const maxW = el.clientWidth  - 24;
    const maxH = el.clientHeight - 24;

    const fits = ()=>{
      const r = span.getBoundingClientRect();
      return (r.width <= maxW && r.height <= maxH);
    };
    while(fs > minPx){
      span.style.fontSize = fs + 'px';
      if(fits()) break;
      fs -= 1;
    }
  }

  // эффекты при удачном клике
  function playPop(el){
    try{
      if(audioPrimed){
        popSound.currentTime = 0;
        popSound.play().catch(()=>{});
      }
    }catch(_){}
    const r = el.getBoundingClientRect();
    for(let i=0;i<14;i++){
      const s = document.createElement('div');
      s.className = 'sparkle';
      s.style.left = (r.left + r.width/2) + 'px';
      s.style.top  = (r.top  + r.height/2) + 'px';
      const angle = Math.random() * Math.PI * 2;
      const dist = 40 + Math.random()*70;
      s.style.setProperty('--dx', (Math.cos(angle)*dist) + 'px');
      s.style.setProperty('--dy', (Math.sin(angle)*dist) + 'px');
      s.style.animationDuration = (0.9 / (SPEED/5)) + 's';
      document.body.appendChild(s);
      setTimeout(()=> s.remove(), 1000);
    }
  }

  // финал
  function showFinish(){
    const ov = document.createElement('div');
    ov.className = 'overlay';
    ov.innerHTML = `
      <div class="panel">
        <div style="font-size:22px; color:#ffd700; font-weight:900; margin-bottom:8px">Финиш! 🎉</div>
        <div style="opacity:.9; margin-bottom:10px">Счёт: <b>${score}</b></div>
        <button id="btnAgain">Начать заново</button>
      </div>
    `;
    document.body.appendChild(ov);
    ov.querySelector('#btnAgain').onclick = ()=> location.reload();
  }

})();
</script>
</body>
</html>
